ДЗ №10 (SOLID)
Завдання №1
1. Single-responsibility principle
Приклад 1: 
Нехай маємо модельний клас User, що містить дані про користувача. Якщо ми додамо до цього класу 
функціонал друкування інформації про користувача, додавання користувача до бази даних чи інший
функціонал, безпосередньо не пов'язаний з сутністю користувача, отримуємо порушення принципу SRP.
Щоб уникнути порушення принципу, в даному випадку розіб'ємо наш клас User на декілька менших класів, 
що будуть виконувати безпосередньо свої завдання (наприклад, отримаємо окремі класи Logger, Printer
тощо, що будуть виконувати свою конкретну задачу). Таким чином, сервісні класи будуть здатні працювати
не тільки з одним класом User, а із іншими класами. В той же час, з модельним класом User буде значно 
легше працювати.
Приклад 2:
Нехай маєио клас Animal в контексті зоопарку. Будемо мати функціонал, що стосується безпосередньо 
тварини (наприклад, методи Eat и Sleep). Якщо до цього ж класу ми додамо метод Feed, що буде
відповідальний за годування тварини (або, наприклад, будь-яку іншу дію, що відбувається над твариною), 
ми порушимо SRP. В такому разі я пропоную винести метод Feed до класу Visiter. Викликаючи цей метод, 
будемо передавати в нього об'єкт класу Animal, а в тілі метода у переданого об'єкта будемо викликати метод
Eat.
2. Open-closed principle
Приклад:
Нехай маємо клас SimpleCoffeeMachine, що має метод MakeBlackCoffee. Припустимо, що ми хочемо створити
іншу модель кавового апарату, що буде вміти заварювати каву з молоком. Ми маємо кілька способів розширити
функціонал базового кавового апарату: використати наслідування і додати новий функціонал (або перевизначти
вже існуючий) до класу наслідника (але таким чином, ми будемо вимушені обов'язково вносити зміни і до 
клієнтського коду) або винести базовий функціонал до інтерфейсу, що буде імплементований в обох класах, 
та додати необхідний додатковий функціонал чи створити власну імлементацію методу (цей спосіб є гнучкішим, 
адже дозволить рівноправно працювати в клієнтському коді з обома класами). В той же час, не треба змінювати 
старий робочий клас, адже він може бути протестованим, стабільно працюючим та може використовуватися й в 
інших проєктах, тому його зміна безпосередньо вплине і на інші проєкти.
3. Liskov substitution principle
Приклад 1:
Будемо мати клас Bird, що буде мати метод Fly. Створимо клас Penguin, що буде наслідувати клас Bird. Так як
пінгвін літати не може, подана конфігурація порушить LSP, адже привівши клас наслідник до базового типу, ми маємо 
бути впевнені, що все буде працювати стабільно. Щоб розв'язати цю проблему, клас Bird має мати більший рівень 
абстракції (мати тільки ті дані та функціонал, що стосуються всіх об'єктів в ієрархії), а метод Fly в той же
час можна винести до інтерфейсу IFly і реалізувати його лише в тих класах, де він дійсно буде потрібен.
Приклад 2:
Маємо клас Car, де визначено метод FillUpGas, що буде відповідальний за заправку машини бензином. Але не кожна 
машина використовує бензин як тип палива, тому ми зіткнемося з проблемами при створенні класу машини, що їздить 
на дизелі. Аналогічно з минулим прикладом, винесемо функціонал, що відповідальний за заправлення машини до інтерфейсу
і будемо реалізовувати необхідний інтерфейс в конкретних класах за необхідності (IFillUpGas в машині, що їздить на
бензині, чи IFillUpDiesel в машині, що їздить на дизелі).
4. Interface segregation principle
Приклад 1:
Створимо інтерфейс IPerson, що міститиме базові функції людини (Eat, Sleep, Walk, Read etc). Ми без проблем можемо
імплементувати цей інтерфейс в класі Person. Але в той же час при створенні класу Animal ми не зможемо реалізувати 
інтерфейс, бо, наприклад, тварина не може читати. Хоча було б цілком логічно і зручно, щоб людина і тварина
могли реалізовувати одні й ті ж самі інтерфейси. Таким чином, розділивши інтерфейс на купу малих інтерейсів,
ми зможемо реалізувати необхідну частину в класі Person та необхідну частину в класі Animal.
Приклад 2:
Нехай маємо 2 оркестри: Orchestra1 i Orchestra2. Перший складається з гітаристів, піаністів та скрипалів, а другий - 
з гітаристів, піаністів, скрипалів, басистів та саксофоністів. Щоб виконати ISP principle ми маємо створити декілька
інтерефейсів, що відповідатимуть за гру на різних музичних інструментах - IPlayGuitar, IPlayViolin тощо. Реалізувавши
тільки необхідні інтерфейси, отримаємо правильно працюючу систему.
5. Dependency inversion principle
Приклад: 
Нехай, отримуючи деякі дані, будемо використовувати фільтр, щоб фільтрувати дані за якимись властивостями. Для цього
створимо сервіс IFilter та його конкретну реалізацію MyOwnFilter. Для роботи з даними визначимо клас ProcessData, в 
конструктор якого будемо передавати об'єкт класу, що імплементує інтерфейс IFilter. В конструкторі проініціалізуємо 
поле змінну _filter типу IFilter. Таким чином, якщо ми захочемо змінити тип фільтра (наприклад, визначимо тип 
MyAnotherFilter), ми без проблем зможемо передати його в конструктор і далі працювати з цією реалізацією IFilter. 
Таким чином, в робочому класі ProcessData ми залежимо не від чіткої реалізації сервісу фільтрування, а від абстракції, 
що надає гнучкості.
